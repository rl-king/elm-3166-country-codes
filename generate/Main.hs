{-# LANGUAGE OverloadedStrings #-}

-- | Generate Elm files
--
-- Data provided by https://github.com/stefangabos/world_countries
module Main where

import Data.Aeson ((.:))
import qualified Data.Aeson as Aeson
import qualified Data.Either as Either
import qualified Data.List as List
import Data.Text (Text)
import qualified Data.Text as Text
import qualified Data.Text.Lazy as TL
import Data.Text.Lazy.Builder (Builder)
import qualified Data.Text.Lazy.Builder as Builder
import qualified Data.Text.Lazy.IO as Text
import qualified System.Directory as Dir
import System.FilePath.Posix ((<.>), (</>))
import qualified System.FilePath.Posix as Path
import qualified Text.Read as Text
import Prelude hiding (unlines)

main :: IO ()
main =
  let languageModule_ (short, long, moduleName) =
        generateModule
          ("world_countries/data/countries/" </> short </> "world.json")
          (List.foldl (</>) "Iso3166" moduleName)
          (languageModule
            (Builder.fromText (Text.pack long))
            (Builder.fromText (Text.pack (List.intercalate "." moduleName)))
          )
   in do
        generateModule "world_countries/data/countries/en/world.json" "Iso3166" mainModule
        mapM_
          languageModule_
          [ ( "ar", "Arabic", [ "Arabic" ] ),
            ( "bg", "Bulgarian", [ "Bulgarian" ] ),
            ( "cs", "Czech", [ "Czech" ] ),
            ( "da", "Danish", [ "Danish" ] ),
            ( "de", "German", [ "German" ] ),
            ( "el", "Greek", [ "Greek" ] ),
            ( "en", "English", [ "English" ] ),
            ( "eo", "Esperanto", [ "Esperanto" ] ),
            ( "es", "Spanish", [ "Spanish" ] ),
            ( "et", "Estonian", [ "Estonian" ] ),
            ( "eu", "Basque", [ "Basque" ] ),
            ( "fi", "Finnish", [ "Finnish" ] ),
            ( "fr", "French", [ "French" ] ),
            ( "hr", "Croatian", [ "Croatian" ] ),
            ( "hu", "Hungarian", [ "Hungarian" ] ),
            ( "hy", "Armenian", [ "Armenian" ] ),
            ( "it", "Italian", [ "Italian" ] ),
            ( "ja", "Japanese", [ "Japanese" ] ),
            ( "ko", "Korean", [ "Korean" ] ),
            ( "lt", "Lithuanian", [ "Lithuanian" ] ),
            ( "nl", "Dutch", [ "Dutch" ] ),
            ( "no", "Norwegian", [ "Norwegian" ] ),
            ( "pl", "Polish", [ "Polish" ] ),
            ( "pt", "Portuguese", [ "Portuguese" ] ),
            ( "ro", "Romanian", [ "Romanian" ] ),
            ( "ru", "Russian", [ "Russian" ] ),
            ( "sk", "Slovak", [ "Slovak" ] ),
            ( "sl", "Slovenian", [ "Slovenian" ] ),
            ( "sv", "Sweden", [ "Sweden" ] ),
            ( "sr", "Serbian", [ "Serbian" ] ),
            ( "th", "Thai", [ "Thai" ] ),
            ( "uk", "Ukrainian", [ "Ukrainian" ] ),
            ( "zh", "Chinese (Simplified)", [ "Chinese" ] ),
            ( "zh-tw", "Chinese (Traditional)", [ "Chinese", "Traditional" ] )
          ]

generateModule :: FilePath -> FilePath -> ([Country] -> Builder) -> IO ()
generateModule file dest toBuilder = do
  eitherCountries <- Aeson.eitherDecodeFileStrict file
  case eitherCountries of
    Left err ->
      putStrLn $ dest <> err
    Right countries -> do
      -- Text.putStrLn . Builder.toLazyText . toBuilder . take 3 $ List.sortOn cAlpha2 countries
      Text.writeFile ("src" </> dest <.> "elm") . Builder.toLazyText . toBuilder $
        List.sortOn cAlpha2 countries

-- COUNTRY

data Country = Country
  { cNumeric :: Int,
    cName :: Text,
    cAlpha2 :: Text,
    cAlpha3 :: Text
  }
  deriving (Show)

instance Aeson.FromJSON Country where
  parseJSON =
    Aeson.withObject "Country" $
      \v ->
        Country
          <$> v .: "id"
          <*> v .: "name"
          <*> v .: "alpha2"
          <*> v .: "alpha3"

-- ELM CODE GEN

mainModule :: [Country] -> Builder
mainModule countries =
  let countryCode = "CountryCode"
      toAlphaTwo = "toAlpha2"
      fromAlphaTwo = "fromAlpha2"
      toAlphaThree = "toAlpha3"
      fromAlphaThree = "fromAlpha3"
      toNumeric = "toNumeric"
      fromNumeric = "fromNumeric"
      all = "all"
      funs = [toAlphaTwo, fromAlphaTwo, toAlphaThree, fromAlphaThree, toNumeric, fromNumeric, all]
   in unlines
        [ "module Iso3166" <> space <> "exposing (CountryCode(..)," <> mconcat (List.intersperse "," funs) <> ")",
          "",
          "-- Generated by 'generate/Main.hs' do not edit by hand",
          "",
          toDoc
            [ "Convert to and from Iso3166 country codes.",
              "@docs" <> space <> toAlphaTwo,
              "@docs" <> space <> fromAlphaTwo,
              "@docs" <> space <> toAlphaThree,
              "@docs" <> space <> fromAlphaThree,
              "@docs" <> space <> toNumeric,
              "@docs" <> space <> fromNumeric,
              "@docs" <> space <> all,
              "# Definition",
              "@docs" <> space <> countryCode
            ],
          "",
          toDoc ["`GT` and `LT` are defined in `Basics` so we define them as `GT_` and `LT_`."],
          toCustomType countryCode toAlpha2 countries,
          "",
          toDoc ["Two-letter `ISO 3166-1 alpha-2` code from `CountryCode`."],
          toFun toAlphaTwo [countryCode, "String"] ["c"],
          toCaseExpr "c" (\c -> (toAlpha2 c, string . Builder.fromText $ cAlpha2 c)) countries,
          "",
          toDoc ["`CountryCode` from two-letter `ISO 3166-1 alpha-2` code."],
          toFun fromAlphaTwo ["String", "Maybe" <> space <> countryCode] ["s"],
          toCaseExpr "s" (\c -> (string . Builder.fromText $ cAlpha2 c, "Just" <> space <> toAlpha2 c)) countries,
          indent <> indent <> "_ -> Nothing",
          "",
          toDoc ["Three-letter `ISO 3166-1 alpha-3` code from `CountryCode`."],
          toFun toAlphaThree [countryCode, "String"] ["c"],
          toCaseExpr "c" (\c -> (toAlpha2 c, string . Builder.fromText $ cAlpha3 c)) countries,
          "",
          toDoc ["`CountryCode` from three-letter `ISO 3166-1 alpha-3` code."],
          toFun fromAlphaThree ["String", "Maybe" <> space <> countryCode] ["s"],
          toCaseExpr "s" (\c -> (string . Builder.fromText $ cAlpha3 c, "Just" <> space <> toAlpha2 c)) countries,
          indent <> indent <> "_ -> Nothing",
          "",
          toDoc ["`ISO 3166-1 numeric` code from `CountryCode`."],
          toFun toNumeric [countryCode, "Int"] ["c"],
          toCaseExpr "c" (\c -> (toAlpha2 c, Builder.fromText . Text.pack . show $ cNumeric c)) countries,
          "",
          toDoc ["`CountryCode` from `ISO 3166-1 numeric` code."],
          toFun fromNumeric ["Int", "Maybe" <> space <> countryCode] ["i"],
          toCaseExpr "i" (\c -> (Builder.fromText . Text.pack . show $ cNumeric c, "Just" <> space <> toAlpha2 c)) countries,
          indent <> indent <> "_ -> Nothing",
          "",
          toDoc ["All `CountryCode`s sorted alphabetically."],
          toFun all ["List" <> space <> countryCode] [],
          indent <> toList toAlpha2 countries
        ]

-- TRANSLATION MODULE

languageModule :: Builder -> Builder -> [Country] -> Builder
languageModule languageName moduleName countries =
  unlines
    [ "module Iso3166." <> moduleName <> space <> "exposing (toName)",
      "",
      "-- Generated by 'generate/Main.hs' do not edit by hand",
      "",
      "{-|",
      "@docs" <> space <> "toName",
      "-}",
      "",
      "import Iso3166 exposing (..)",
      "",
      toDoc
        [ "Name for `CountryCode` in " <> languageName <> ".",
          "",
          "```",
          unlines $ fmap ((\(a, b) -> a <> space <> b) . countryCase) countries,
          "```"
        ],
      toFun "toName" ["CountryCode", "String"] ["c"],
      toCaseExpr "c" countryCase countries
    ]

countryCase :: Country -> (Builder, Builder)
countryCase country =
  ( toAlpha2 country,
    string (Builder.fromText (cName country))
  )

-- HELPERS

toAlpha2 :: Country -> Builder
toAlpha2 c
  | cAlpha2 c == "gt" = "GT_"
  | cAlpha2 c == "lt" = "LT_"
  | otherwise = Builder.fromText . Text.toUpper $ cAlpha2 c

-- BUILDERS

toDoc :: [Builder] -> Builder
toDoc ds =
  "{-|" <> space <> unlines ds <> newline <> "-}"

toCustomType :: Builder -> (a -> Builder) -> [a] -> Builder
toCustomType var f xs =
  case xs of
    [] -> ""
    hd : rest ->
      unlines
        [ "type" <> space <> var,
          indent <> "=" <> space <> f hd,
          unlines $ fmap (\cs -> indent <> "|" <> space <> f cs) rest
        ]

toFun :: Builder -> [Builder] -> [Builder] -> Builder
toFun var xs args =
  unlines
    [ var <> space <> ":" <> space <> mconcat (List.intersperse " -> " xs),
      var <> space <> mconcat (List.intersperse space args) <> space <> "="
    ]

toList :: (a -> Builder) -> [a] -> Builder
toList f xs =
  "[" <> space <> mconcat (List.intersperse "," (fmap f xs)) <> space <> "]"

toCaseExpr :: Builder -> (a -> (Builder, Builder)) -> [a] -> Builder
toCaseExpr var f xs =
  unlines
    [ indent <> "case" <> space <> var <> space <> "of",
      unlines (fmap (toCase . f) xs)
    ]

toCase :: (Builder, Builder) -> Builder
toCase (match, result) =
  indent <> indent <> match <> space <> "->" <> space <> result

space :: Builder
space =
  Builder.singleton ' '

string :: Builder -> Builder
string s =
  "\"" <> s <> "\""

indent :: Builder
indent =
  "    "

newline :: Builder
newline =
  Builder.singleton '\n'

unlines :: [Builder] -> Builder
unlines =
  mconcat . List.intersperse newline

uppercase :: Text -> Builder
uppercase =
  Builder.fromText . Text.toUpper
